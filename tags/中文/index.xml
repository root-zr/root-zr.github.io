<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>中文 on Albert Wang</title>
    <link>https://root-zr.github.io/tags/%E4%B8%AD%E6%96%87/</link>
    <description>Recent content in 中文 on Albert Wang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 May 2023 13:39:37 +0800</lastBuildDate><atom:link href="https://root-zr.github.io/tags/%E4%B8%AD%E6%96%87/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DFS and BFS with Graph | 无向图深度优先与广度优先</title>
      <link>https://root-zr.github.io/en/2023/05/01/dfs-and-bfs-with-graph-%E6%97%A0%E5%90%91%E5%9B%BE%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</link>
      <pubDate>Mon, 01 May 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/05/01/dfs-and-bfs-with-graph-%E6%97%A0%E5%90%91%E5%9B%BE%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</guid>
      <description>背景 我们来看这样一道经典的题目，一个矩阵中有 0 和 1 两种元素，现在要从左上角开始遍历，每次可以选择八个方向，并且只能访问值为 0 的节点，问它最短需要走多少步才能到达，查看原题可以点击这里 。
这就是一个非常典型的遍历无向图的例子了，下面我们分别介绍 DFS 和 BFS 需要注意些什么。
DFS 我们先假设在上图中机器人先选择向下走了一步，然后它就到了（1，0）这个点，在这个点上它可以选择向任意四个方向前进，但是又不能走出去，所以它可选的方向就只有三个，分别是向下，向右和向上。假如它选择了向上，那它就又回到了（0，0）这个点，当它回到原点之后它有可以选择来到（1，0），这样重复之后程序就永远不可能会退出了。
针对这种情况我们来思考一下解决办法，之所以出现这种情况，是因为它走了重复的路。而它一旦走了重复的路，那这条路必然就不可能是最短的路，所以我们要禁止这种情况的发生。代码里通常有两种做法来避免这种情况的发生，一种是很直观的禁止它走“回头路”，代码实现如下
class Solution { int ans; int[][] paths = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}; boolean[][] isVisited; public boolean valid(int[][] grid, int x, int y) { if (x &amp;lt; 0 || x &amp;gt;= grid.length || y &amp;lt; 0 || y &amp;gt;= grid[0].length) { return false; } if (isVisited[x][y] || grid[x][y] == 1) { return false; } return true; } public void backtrack(int[][] grid, int x, int y, int cnt) { if (!</description>
    </item>
    
    <item>
      <title>The Shortest Path of Graphs | 图的最短路问题2</title>
      <link>https://root-zr.github.io/en/2023/04/22/the-shortest-path-of-graphs-%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%982/</link>
      <pubDate>Sat, 22 Apr 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/04/22/the-shortest-path-of-graphs-%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%982/</guid>
      <description>在几个月前我总结了图最短路问题常用的几个算法以及实现 。但是随后我就发现了一个很大的问题，之前算法的实现都是采用的邻接矩阵，这种实现方式最大的问题就是太占用内存空间。假如一个稀疏图有 n 个顶点，m 条边（其中 m &amp;laquo; n)，在这种情况下用邻接矩阵来表示图需要的内存空间是$O(n^2)$，在一些算法题中 n 的数量往往会达到 $10^5$，而给定的内存范围是 $10^9$，这就导致临界矩阵往往不能用来做这些图的题目。如果采用邻接表来表示一个图只需要 $O(n + m)$ 的内存空间，所以下面我们用邻接表来实现Dijkstra 算法。
首先我们来构造图，代码如下。其中 n 表示有 n 个节点，并且节点的值为 0 ~ n - 1，edges 表示边的集合，edge[0]和edge[1]表示从 edge[0] 到 edge[1] 有边，edge[2] 表示这条边的权重。
 public int init(int n, int[][] edges) { ArrayList&amp;lt;Node&amp;gt;[] graph = new ArrayList[n]; for (int i = 0; i &amp;lt; n; i++) { graph[i] = new ArrayList&amp;lt;&amp;gt;(); } for (int[] edge : edges) { graph[edge[0]].add(new Node(edge[1], edge[2])); graph[edge[1]].</description>
    </item>
    
    <item>
      <title>Override equals and hashCode method in HashMap | Java使用HashMap需要重写equals和hashCode方法的场景</title>
      <link>https://root-zr.github.io/en/2023/04/21/override-equals-and-hashcode-method-in-hashmap-java%E4%BD%BF%E7%94%A8hashmap%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99equals%E5%92%8Chashcode%E6%96%B9%E6%B3%95%E7%9A%84%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Fri, 21 Apr 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/04/21/override-equals-and-hashcode-method-in-hashmap-java%E4%BD%BF%E7%94%A8hashmap%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99equals%E5%92%8Chashcode%E6%96%B9%E6%B3%95%E7%9A%84%E5%9C%BA%E6%99%AF/</guid>
      <description>当我们使用对象类型作为 HashMap 的 key的时候，我们往往希望两个对象里的某一个或者某几个成员变量相等，则这两个对象是相等的，而不是说采用 Java 默认的地址空间一致并且值也相等才表示两个对象相等。
假设我们有一个对象 Node表示一个点，它有两个成员变量 a 和 b
class Node { int a; // 表示从a到b int b; public Node(int a, int b) { this.a = a; this.b = b; } } 现在我们创建一个 HashMap，并且在 map 里存入点（1，1）然后我们获取点（1，1）对应的权重。
public class Test { public static void main(String[] args) { HashMap&amp;lt;Node, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); Node node = new Node(1, 1); map.put(node, 2); System.out.println(map.get(new Node(1, 1))); } } 我们运行代码可以发现 map 返回的值是 null 而不是 2，这是因为我们在获取的时候又用 new 关键字创建了一个对象，然后在堆区开辟了一块新的内存空间，这导致这个“新的对象”之前并没有存在hash表里。</description>
    </item>
    
    <item>
      <title>Distributed transaction | 分布式事务</title>
      <link>https://root-zr.github.io/en/2023/03/05/distributed-transaction-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 05 Mar 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/03/05/distributed-transaction-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description>背景 在数据库概念中事务代表着一系列的操作，这些操作需要版满足ACID特性，分别是下面这些操作的首字母
  Atomic：这些操作要么全部被commit，要么都不做；
  Consistent： 一个事务在执行之前和执行之后，数据库都必须处于一致性状态
  Isolatesd: 两个事务之间的操作是隔离的，当事务在执行的时候彼此看不到各自的修改，只能看到事务执行结束之后的结果；
  Durability：事务处理的结果必须被持久化，长期存在
  如果数据库只保存在一台服务器上，设计满足ACID的属性在一般的数据库书籍中都会讲到。但是在大型系统中，数据库的一张表往往保存在多个服务器上，比如银行的存款信息可能一半在A服务器，一半在B服务器，在这种情况之下设计满足ACID的分布式事务就会麻烦很多。
比如我们现在有两个事务 T1 和 T2， 其中 T1 是表示从 x 到 y 的一个转账操作，x 和 y 的值最初都是 10，并且分别保存在服务器 A 和 B 上，T2 表示一次查询操作，它们分别可以用下面这种方式执行
T1 ： BEGIN_X add(x, 1) add(y, -1) END_X T2: BEGIN_X t1 = get(x) t2 = get(y) print t1, t2 END_X 下面我们用两阶段提交的方式来设计分布式事务。
两阶段提交 在两阶段提交方式中有一个专门的服务器用来做事务协调器，A，B 这些服务器叫参与者（paticipants）。首先协调器会发prepare消息给参与者，判断它们能否完成后续的put操作，协调器会回复 YES/NO，分别表示下图中的①和②。当协调器发现两个服务都回复了 YES，协调器会发 commit 消息，参与者 commit 之后会回复 ACK 确认消息，只要有一个回复NO，就会发abort消息，回滚这个事务，如下图的③和④。通过这两个阶段就保证了分布式事务的一致性。</description>
    </item>
    
    <item>
      <title>Segment Tree | 线段树</title>
      <link>https://root-zr.github.io/en/2023/03/03/segment-tree-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Fri, 03 Mar 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/03/03/segment-tree-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>背景 这篇博客主要介绍线段树的相关知识。假如我们需要对区间进行操作，比如需要多次查询某一个区间的和，或者多次查询某一个区间的最大值，或者多次在某些区间上加一个值。很明显，我们操作一次的时间复杂度是O(n)，操作 m 次的时间复杂度是 O(mn)。
对于$O(n^2)$ 这样的时间复杂度来说，我们的数据量一般不能超过$10^5$，但是如果我们有一种手段把它的时间复杂度变成nlogn级别，那效率就会提升很多。
线段树 线段树就是一种很好的解决方案。它的图形化表达如下图所示；
假如我们想要查询某一个区间的和，首先我们知道总的区间是[1, 10]，然后我们把他进行折半，分成[1, 5] 和 [6, 10] 两个区间。然后对这两个子区间再折半，不断地递归下去，知道这个区间已经只有一个元素，也就是对应着叶子节点。
这时对于叶子节点我们很容易知道它的和就是这个元素本身，因为它只有一个元素。对于任意一个非叶子节点来说，它的区间和就是先对它的子结点求和，再把每一个子结点的和相加。
代码实现 不难看出，线段树其实是一棵完全二叉树，所以我们直接用一个一维数组就可以保存树节点信息，类似于堆的存储方式。同样的，对于下标从 0 开始的节点，第 i 棵树必然满足下面的性质
 左子节点下标 2 * i + 1; 右子节点下标 2 * i + 2  我们先来定义每一个节点的的类，用 left, right, sum 分别表示左右子结点和当前区间的和。
class Node { int left; int right; int sum; public Node (int left, int right, int sum) { this.left = left; this.right = right; this.sum = sum; } } 下面就是线段树的实现，它的成员变量就是一个一维数组，用来保存这棵树的节点信息。为了保证空间足够，这里我们按照 num * 4 的规格来创建数组空间。</description>
    </item>
    
    <item>
      <title>Trie Tree | 字典树</title>
      <link>https://root-zr.github.io/en/2023/02/19/trie-tree-%E5%AD%97%E5%85%B8%E6%A0%91/</link>
      <pubDate>Sun, 19 Feb 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/02/19/trie-tree-%E5%AD%97%E5%85%B8%E6%A0%91/</guid>
      <description>背景 假如我们现在有一个单词组成的数组[&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;banana&amp;rdquo;, &amp;ldquo;orange&amp;rdquo;, &amp;hellip;]，我们希望准确地知道某一个单词是否在这个数组里，有什么高效的统计方式呢？
字典树 字典树的设计就是用来解决上面的问题，下图就是一个字典树的示意图，它具有以下的特点：
 它的每条边代表了一个特定的字符； 从根节点到每个节点的路径就是某个字符串的前缀； 一个父结点的子结点数目最多有 26 个，因为只有 26 个单词.  对于下面这张图来说，我们希望知道 &amp;ldquo;cat&amp;rdquo; 在不在字典里，首先我们从根节点出发，先找第一个单词 &amp;lsquo;c&amp;rsquo; 在不在根节点的子结点里；如果在，就找第二个单词 &amp;lsquo;a&amp;rsquo; 在不在 &amp;lsquo;c&amp;rsquo; 的子结点里，这样不断地查找下去。
我们不难发现，对于这棵树来说，它的深度取决于当前字典里最长单词的字母个数，而单词的长度一般不会超过 50，所以这棵树的查找是非常高效的。
字典树除了能很好地判断一个单词是否在这个字典里，它同样可以应用于自动补全和拼写检查。
代码实现 要实现这棵树也非常简单，首先我们需要把这棵树的节点构造出来，这里用一个长度为 26 的数组用来表示某一个字母是否有对应的子结点，还有一个 int 的变量用来表示在这颗树里有多少个单词以当前这个节点结尾。
class Node { Node[] next; int end; public Node() { next = new Node[26]; } } 然后我们需要实现 Trie 的代码，我们只需要通过迭代的方式去插入和查询即可。
public class Trie { Node root; public Trie() { root = new Node(); } public void insert(String word) { char[] arr = word.</description>
    </item>
    
    <item>
      <title>Append Entries of Raft | Raft算法添加条目</title>
      <link>https://root-zr.github.io/en/2023/02/11/append-entries-of-raft-raft%E7%AE%97%E6%B3%95%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE/</link>
      <pubDate>Sat, 11 Feb 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/02/11/append-entries-of-raft-raft%E7%AE%97%E6%B3%95%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE/</guid>
      <description>这篇博客主要记录 raft 算法添加日志条目的过程，这里用到的一些代码和思路主要来源于 MIT 6.824 课程 , 课程中提供的材料raft 论文 和 Github 上一些开源的代码实现。
raft 算法主要是以一种 lib 库的方式嵌入在应用程序中来保证分布式系统的一致性。在课程的实验中将 raft 将项目的结构划分成了下图所示这种方式。
我们假设现在是一个由三台服务器组成的分布式集群（为了保证投票时“大多数”的条件永远成立，这里集群的数目必须是奇数），每台服务器的上层都维护了一个 &amp;lt; key, value &amp;gt; 的数据库，下层是 raft 算法的实现，它们通过 raft.go 里的 Start 函数做为接口进行交互。
在我们彻底弄懂上面那张图表达的意思之前让我们先来了解一下 raft 本身维护了哪些状态，下面的结构体里展示了 raft 自身的全部状态，针对这篇博客的内容，我们大概只需要了解我中文注释的这一部分就可以。这里有些状态是针对 leader 的，有些是 follower 的，有些则是它们共有的属性。分布式系统往往有成百上千台机器，而每台服务器上跑的代码都是一样的。所以当我们在编写代码的时候，必须对什么样的角色可以执行这段代码时刻保持清醒的认知。否则有些流程可能只有 leader 才会执行，如果我们没有事先检验调用者的身份，就会导致 follower 也会执行这部分代码，在一个分布式系统中这种操作导致出错的可能性是非常高的。
type Raft struct { mu sync.Mutex // 用来保证状态一致性的锁 peers []*labrpc.ClientEnd // 保存了集群中每一台服务器的信息，在我们的例子中是3台 persister *Persister // Object to hold this peer&#39;s persisted state me int // “我”这台服务器在 peers 中的位置 dead int32 // set by Kill() state RaftState // Follower, Candidate, Leader 3种状态 appendEntryCh chan *Entry heartBeat time.</description>
    </item>
    
    <item>
      <title>The Shortest Path of Graphs | 图的最短路问题</title>
      <link>https://root-zr.github.io/en/2023/01/07/the-shortest-path-of-graphs-%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 07 Jan 2023 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2023/01/07/the-shortest-path-of-graphs-%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>问题背景 假设我们有下面这张图，图中边的权重表示两点之间的距离。我们希望找到一条最短的路径从这张图的 A 点出发，最终走到 E 点，该怎样考虑这个问题呢？
这个问题很具有现实的意义，假设两点表示两个城市的距离，我们往往希望能够走最短距离的那条路到达目的地。而且这个问题也有一个隐含的条件，那就路的距离不可能为负数，所以我们可以考虑使用 Dijkstra 算法来进行求解。
Dijkstra 算法 Dijkstra 算法考虑对每一个点进行标号，每个点对应着两种状态（固定标号和临时标号，表示已经确定最短路径和尚未确定），一开始只有出发点的状态是已经确定最短路径的，然后会在迭代的时候去更新标号点，同时也会对每个点的最短路径进行更新。
图表模拟 下面我们先用图表的方式来进行模拟 Dijkstra 的求解过程。首先我们用一个数组来存储每个点的状态，最开始只有 A 点的状态是确定的，A 点到 A 点的距离初始化为 0，然后初始化 A 点到其余各点的距离，如果 A 点到某一个点没有路径，则初始化为无穷大。从 A 点开始迭代，更新 A 点到到各点的最短距离，如下图所示
这时我们能确定 A 点到 C 点的最短距离是 3，然后就将 C 点的状态设置为确定，再从 C 点开始迭代，继续更新到其余未确定点之间的最小距离，如下图
这时我们确定了，A 点到 B 点的最短距离是 5，然后将 B 点设置为确定，再更新其他未确定的点。直到最终目的地的点被标注为已确定，如下图所示
这样我们就得到了 A 点到 E 点的最短路径 18. 下面我们用代码来实现上面的算法。
代码实现 我们采用邻接矩阵来实现 dijkstra 算法
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stddef.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #define INF 10000001 #define N 101 int graph[N][N]; void dijkstra(int *distance, int *flag, int n) { int a, b; for (int i = 0; i &amp;lt; n - 1; i++) { a = -1; b = INF; for (int j = 1; j &amp;lt; n; j++) { // 找出发点到 j 点的最小距离 if (flag[j] == 0 &amp;amp;&amp;amp; distance[j] &amp;lt; b) { a = j; b = distance[j]; } } if (a == -1) { // 没有路到终点 break; } if (a == n - 1) { // 已经找到了到终点的最短路 break; } flag[a] = 1; // 改为固定标号 for (int j = 1; j &amp;lt; n; j++) { if (flag[j] == 0 &amp;amp;&amp;amp; (b + graph[a][j] &amp;lt; distance[j])) { distance[j] = b + graph[a][j]; } } } if (distance[n - 1] &amp;gt;= INF) { printf(&amp;quot;Impossible!</description>
    </item>
    
    <item>
      <title>Hamiltonian Graph | 哈密顿图</title>
      <link>https://root-zr.github.io/en/2022/12/31/hamiltonian-graph-%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE/</link>
      <pubDate>Sat, 31 Dec 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/12/31/hamiltonian-graph-%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE/</guid>
      <description>这篇博客是对上一篇博客欧拉图的补充，主要介绍中国邮递员问题和哈密顿图。
中国邮递员问题 中国邮递员问题是说现在有一个邮递员，他每一天要从邮局出发给自己负责的街道去送信，送完之后再回到邮局，问怎样走路程最短？
这个问题和欧拉图非常相似，特别地，如果这个邮递员负责的街道刚好可以构成一个欧拉图，那么最短的路程就是欧拉回路，因为相当于每条街道刚好走了一次。否则就会存在一条街道被走多次的情况，下面我们就来分析这种情况下的处理办法。
我们已经知道如果一个图存在欧拉回路，每个节点的度数一定是偶数。所以要想把一个图变成欧拉图，就需要把它的奇度数节点都变成偶度数节点，就需要在原图中增加一些边。为了保证路程最小，我们需要对加的边进行一些调整，下面有一些被证明的结论
 最优方案中，图中每条边的重数一定是小于等于2的（一条街道最多走两次）； 图中每个基本回路上平行边的总权值不大于该回路的权值的一半。  哈密顿图 邮递员问题解决的是送货上门的情况，对于蜂巢快递柜这种情况就不是很适用。我们不妨假设邮局和快递柜都是节点，它们之间的路为边，对于这个问题，我们则是希望遍历所有的节点，最后再回到原点，这和之前的遍历所有的边就不一样了。假如存在这样的一个回路，使得我们可以刚好遍历每个节点一次，最终回到原点，这个回路就被称之为哈密顿回路，存在哈密顿回路的图被称为哈密顿图。
这个问题看起来和欧拉图比较类似，只是将边换成了节点，但是目前却没有一个能求解这个问题的充要条件，这看起来是一个令人沮丧的消息，但是我们可以有一些充分条件来判断某个图是不是哈密顿图。
 如果G = &amp;lt;V, E&amp;gt; 是一个有 n 个节点的简单图，对于任意两个不想邻的节点u, v，则一定有deg(u) + deg(v) &amp;gt;= n - 1。  上面的结论可以很有效地帮助我们去判断某个图是不是哈密顿图。</description>
    </item>
    
    <item>
      <title>Euler Graph | 欧拉图</title>
      <link>https://root-zr.github.io/en/2022/12/17/euler-graph-%E6%AC%A7%E6%8B%89%E5%9B%BE/</link>
      <pubDate>Sat, 17 Dec 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/12/17/euler-graph-%E6%AC%A7%E6%8B%89%E5%9B%BE/</guid>
      <description>戈尼斯堡七桥问题 我们先来看一个经典问题。假如有两座小岛，大的小岛和旁边的陆地有四座桥相连，小的岛和陆地有两座桥相连，两个小岛之间有一座桥相连。相当于说有四座陆地，七座桥，问从任何一块陆地出发，每座桥只走一次，最终能否回到原点。类似的问题是一笔画问题（从某一个点出发，不能提起笔，问最终能否回到原点）。
我们可以把上面的问题抽象成右上角所示的图模型，点表示陆地，连线表示桥，这就构成了一个图模型。我们现在来考虑怎么对这个模型进行表达。
图的表示 对于上面的这个图模型来说，我们从数学上可以得到三个集合，点的集合V(G)，边的集合E(G)和边到实数的一个映射函数F(G)（通常表示权重）。在计算机中则是主要通过邻接矩阵和邻接表这两种方式来表示图。
邻接矩阵 邻接矩阵是一个二维的方阵，其中 matrix[i] [j] 用来表达节点 i 和节点 j 是否关联。在图初始化的时候通常以二维数组的方式作为输入，其中第二维表示两个节点和节点之间的关系，比如下面的这个输入就表示节点 1 和节点 2 之间是有边的，并且边的权重为 10。在有些情况下权重是可以忽略的，我们更关心节点间是否连通。
1 2 10 为了符合人类的思考方式，往往节点坐标都是从 1 开始的，这里我们也先假设点的坐标是从 1 开始，然后给出邻接矩阵的实现代码。
#define MAX_SIZE 100 int main() { int n, m, u, v; int matrix[MAX_SIZE][MAX_SIZE] = {0}; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); for (int i = 0; i &amp;lt; m; i++) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;u, &amp;amp;v); matrix[u - 1][v - 1] = 1; matrix[v - 1][i - 1] = 1; // 无向图的连接方式 } return 0; } 如果边是有权的，我们在最初赋值的时候会给定一个无穷大的值表示不可访问，如果i == j ，权值为 0。</description>
    </item>
    
    <item>
      <title>Union-Find Disjoint Sets | 并查集</title>
      <link>https://root-zr.github.io/en/2022/12/10/union-find-disjoint-sets-%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sat, 10 Dec 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/12/10/union-find-disjoint-sets-%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>算法介绍 并查集主要用于集合之间的操作。对于两个集合而言，它们一般能做的就是将两个集合的元素合并（并）。同时，我们往往会希望知道两个元素在不在同一个集合中（查）。由此便引出了并查集这种数据结构。
为了便于理解，我们先将问题进行简化。假如目前摆在我们面前的有这样一个图
在这个图中 每两个节点之间的连通关系和它们之间的距离可以用如下的二维数组来表示，
[[1,2,9],[2,3,6],[2,4,5],[1,4,7]] 我们现在希望找到一种数据结构，从我们给定的联通关系中从 0 构建上面的那张图，并且可以高效地实现查找某一个节点在不在这张连通图里面。所以我们可以将它们用一个一维数组的方式来存储，如下图所示
我们将数组的下标用来表示元素节点，用数组下标对应的值来表示它们的父亲节点，这样就可以构建一个father数组。我们在初始化的时候可以将它们的父亲节点都初始化成自己，这时对应的图就是每个节点各自都不连通，然后我们在用并查集的并来对这个数组进行赋值（这时我们不妨先假设father数组已经构建好了）。
public int findFather(int n) { if (fa[n] == n) { return n; } return findFather(fa[n]); } public void unionSet(int i, int j) { int faI = findFather(i); int faJ = findFather(j); if (faI != faJ) { fa[faJ] = faI; } } 我们首先来观察 findFather 这个函数，这个函数做的事情就是找一个节点的根节点。如果一个节点的父结点就是它自己的话说明我们已经找到这棵树的根了，然后就返回这个节点的 id。否则，我们就找这个节点父结点的父结点，也就是它的“爷爷节点”，逐层向上递归，最终我们一定能找到这个节点所在集合的根节点，并且保证时间复杂度是线性的。
然后我们再来观察 unionSet 这个函数，这个函数首先会去找两个元素i，j 的根节点，如果它们的根节点是一样的，说明它们在一个集合里，这里我们不进行操作；否则，说明它们在不同的集合，这时我们要做的操作就是把这两个集合合并起来，我们只需要让其中一个根节点的父结点变成另一个节点就可以了。这样我们就完成了两个集合的合并操作。
到这里并查集的任务基本已经完成了，我们来思考一下有没有什么可以进一步优化的空间。手下来看 findFather 这个函数，我们显然可以知道它的时间复杂度是线性的。也就是说，如果我们的运气足够差，当我们目前构建的这个树退化成了单向链表，在时间上我们就要付出更大的成本了。所以可以考虑有一种优化的方式，因为我们在调用这个函数的时候只想知道根节点是谁，并不一定要记录每个节点的父结点，所以我们可以在初始化的时候将每个节点的父结点都设置为根节点，代码表示如下
public int findFather(int n) { if (fa[n] == n) { return n; } return fa[n] = findFather(fa[n]); } 这段代码需要说明的一点是 fa[n] = findFather(fa[n]) 这个表达式本身是有返回值的，返回值是 fa[n] 最终被赋予的那个值。</description>
    </item>
    
    <item>
      <title>Memory Allocation of Linux 0.11 | Linux 0.11 内存区域划分</title>
      <link>https://root-zr.github.io/en/2022/10/06/memory-allocation-of-linux-0.11-linux-0.11-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</link>
      <pubDate>Thu, 06 Oct 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/10/06/memory-allocation-of-linux-0.11-linux-0.11-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/</guid>
      <description>内存区域划分 Linux 0.11 内核默认最多支持 16M 物理内存。它的内核模块在物理内存的最前端。然后是高速缓冲区，高速缓冲区是磁盘等块设备临时存放数据的地方，高速缓冲区的最高内存地址可以是 4M，下图中高速缓冲区还要扣除显存和 BIOS ROM 占用的部分。剩余部分才是主内存区，如果系统中还有 RAM 虚拟磁盘，主内存区的前段还要扣除虚拟盘所占的内存空间。如下图所示，
我们来看一下具体在代码中的实现， 下面代码中 ROOT_DEV 表示根设备号， buffer_memory_end 表示高速缓冲区的末端地址， memory_end 表示机器的内存数，main_memory_start 则表示主存的开始地址。
ROOT_DEV = ORIG_ROOT_DEV; // 0x901fc drive_info = DRIVE_INFO; // 0x90080 memory_end = (1&amp;lt;&amp;lt;20) + (EXT_MEM_K&amp;lt;&amp;lt;10); memory_end &amp;amp;= 0xfffff000; if (memory_end &amp;gt; 16*1024*1024) memory_end = 16*1024*1024; if (memory_end &amp;gt; 12*1024*1024) buffer_memory_end = 4*1024*1024; else if (memory_end &amp;gt; 6*1024*1024) buffer_memory_end = 2*1024*1024; else buffer_memory_end = 1*1024*1024; main_memory_start = buffer_memory_end; #ifdef RAMDISK 	main_memory_start += rd_init(main_memory_start, RAMDISK*1024); #endif 	mem_init(main_memory_start,memory_end); 上面的代码首先初始化了根设备号和硬盘参数表，然后设置内存的大小为 1M + 扩展内存 * 1024 字节，memory_end &amp;amp;= 0xfffff000; 则是表示忽略不到 4K 的内存数。</description>
    </item>
    
    <item>
      <title>Run Linux with Bochs | Bochs运行Linux操作系统</title>
      <link>https://root-zr.github.io/en/2022/10/04/run-linux-with-bochs-bochs%E8%BF%90%E8%A1%8Clinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 04 Oct 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/10/04/run-linux-with-bochs-bochs%E8%BF%90%E8%A1%8Clinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>操作系统是一个神奇的软件，它管理了各种硬件，所以它本身足够复杂。同样也是这个原因导致我们要对操作系统的代码进行调试变得非常困难。
本文是一篇介绍怎样用 Bochs 来运行和调试 Linux 0.11 的博客。选择 Bochs 而不是 VM Ware 的原因是 Bochs 仿真了 X86 的硬件环境和外设，而VM Ware 则是仿真了一些 I/O 功能，其他是依靠 X86实时硬件执行的。这样虽然 Bochs 在速度上不如 VM Ware，但是因为它具备更加精确的状态和时序，所以更适合开发底层系统软件。 Linux 选择 0.11 的原因则是当前的 Linux 版本太过于庞大，基本不可能完全阅读完它的代码。相比之前 0.11 版本的代码总共也就几万行，而且是一个相对完整的操作系统，所以用它是比较适合的。
Bochs安装和运行Linux 我们之前认为 Bochs 更适合操作系统，幸运的是大家都是这么想的，所以我们已经有完善的软件包可以帮助我们完成这一步了。点击这里 可以下载Linux 0.11 的软件包，解压缩之后可以看到下面的内容。
上图中第一个.exe的文件就是Windows 下 Bochs 的安装文件，.rpm 是 Linux 下的安装文件。本文以 Windows 下为例，双击按照常规安装应用软件的方式安装即可。
上图中 .bxrc 文件是 Bochs 的配置文件，它们的参数各不相同。这里简单介绍一下 bochsrc-hd.bxrc。这个配置文件从启动软盘（A盘）加载内核映像文件 booting-0.11-hd，使用硬盘映像文件 hdc-0.11-new.img 第一个分区中的跟文件系统。
在安装完 Bochs 后直接点击 bochsrc-hd.bxrc 就能进入模拟环境，如下图所示。我们看到当前目录下有 hello 的可执行文件，我们可以直接运行它，会在控制台打印出 hello world！
Linux 代码调试 调试代码要用到的是 Bochs 的 debug 功能，类似于 GDB。首先我们要修改 debug.</description>
    </item>
    
    <item>
      <title>Summary of My University Life | 我的大学四年总结</title>
      <link>https://root-zr.github.io/en/2022/07/16/summary-of-my-university-life-%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 16 Jul 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/07/16/summary-of-my-university-life-%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4%E6%80%BB%E7%BB%93/</guid>
      <description>这是一篇相对迟到的大学生涯总结，自从看到学校的凤凰花开，我就有了想写一篇总结的想法，但是由于种种原因一直都没有去做。迟迟没法开始的主要原因是没什么内容可以写，因为我觉得自己并不是一个优秀的人，在我的学习生涯中可能更多的是失败的教训而非成功的经验。所以我一直希望找到一个合适的切入角度来对我过去四年的经历做一个总结，直到最近我才找到一个自己比较满意的方式，那就是去尽量回忆一些让我比较感动和难忘的事，好方便自己在若干年后做一个回顾。而且上周经过公司组织的入职导航培训，我也很快要去到自己的部门工作，真正完成从大学到职场的环境转变，刚好可以趁着这个时候对自己之前的经历打个结，收拾好行囊，重新出发。
我所在的学校是一所理工类的大学，所以学校的理工科氛围非常浓厚，一定程度上就造成了人文气息的缺失。我在很多地方都看到有同学吐槽这种现象（我看到大家吐槽学校最多的两个方面就是人文气息和行政教务了），希望能有更多人文类的课程或者活动，好让大家可以更加多元化发展。这样的说法固然有一定的道理，但是就我个人而言，正是因为这种氛围才让我成功遵从自己的内心，让我找到自己真正热爱的东西，并且把它变成我后续的职业。所以我个人还是得感谢学校，感谢她的开放包容和支持学生自由发展的制度。
一路走来我受到了很多同学的帮助，他们都很优秀，每个人身上都有很多值得我去学习的地方。这种优秀不只表现在学习方面，更多体现在生活和为人处世上。他们始终都能保持正直，善良，乐观的心态。比如发现乒乓球馆内没有人但是灯还是开着，他们都会走过去把它关掉；如果有什么任务交代给他们，即便有时候可能会打乱自己原先的安排，他们也可以第一之间完成，绝对不让别人为难。这些事情虽小，但能让我不断认识自己的不足，并且尝试去改正，朝着一个更好的自己去迈进。
没有通宵写作业和复习过的大学是不完整的，很幸运我有这样的经历。夜深的时候一切都很安静，总能启发我去思考，看着任务一点点减少，兴奋的感觉也可以渐渐冲淡疲倦的感觉。
多一个应急求生的技能总是不错的，学校提供了游泳课，并且强制性让每位同学去学，大概率也是出自这个原因吧。而我在上游泳课之前以为自己可以通过系统的学习，在看到别人溺水的时候也可以像影视剧中表现的那样冲过去然后成功将其救上岸。后面才发现我能保证自己成功游上岸就已经很不错了，不过不管怎么说，对于一个土生土长的北方人来讲，会游泳总是一件让人骄傲的事。
身体是革命的本钱，每个人都知道这句话，但却不是每个人都愿意坚持锻炼身体，我上大学之前也是如此。不过为了体育成绩，也为了体测可以过75拿到奖学金，我还是坚持完成了步道乐跑的强制性3公里打卡，并且在后面可以尽量坚持每晚跑步。虽然一开始我并不是自愿去做这件事，但是现在有一个相对健康的身体可以去996也挺感谢学校让我养成的这个习惯。关于锻炼同样有一件事让我印象比较深，我们几个同学在实习的时候从公司汽车到学校，一路上骑地飞快，可还是花了好几个小时，最后回去的时候大家都大汗淋漓。现在回想起来依旧感觉很好玩。平时实习回学校都是坐地铁回去的，但从CBD到学校刚开始的那一站真的好挤。如果可以的话，我以后还是希望尽量可以少一点挤地铁的经历哈哈。
大学虽说也读了一些书，但基本都是和专业相关，或者是一些技术类的书籍，人文方面的书读得很少，只有大一的时候喜欢在图书馆四楼人文书库自习，每当做题累了的时候就会去旁边书架上找书看，所以连带着看了很多大佬的人物传记。除了这些书之外我竟然一时想不到还看过别的什么书目，实在是有点惭愧。
我在大学时成为了一名中共党员，我自认为自己入党的动机还是比较纯的，不管从什么角度考虑，全心全意为人民服务这一点就很值得我成为他们的一员。而且对于个人而言，有一个信仰也没什么不好。
毕业的时候学校为我们每个人提供了一份电子档案，记录了每个人修了多少学分，泡图书馆多少次等等的信息。我觉得这些冷冰冰的数字其实并没有多少意义，所以我尽量回忆了一些比较笼统和自己感觉重要的事情，权当做一个总结。</description>
    </item>
    
    <item>
      <title>A Slide for Zookeeper Learning | zookeeper学习中的PPT分享</title>
      <link>https://root-zr.github.io/en/2022/07/07/a-slide-for-zookeeper-learning-zookeeper%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84ppt%E5%88%86%E4%BA%AB/</link>
      <pubDate>Thu, 07 Jul 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/07/07/a-slide-for-zookeeper-learning-zookeeper%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84ppt%E5%88%86%E4%BA%AB/</guid>
      <description>这是一篇用来测试共享文件的博客，分享了一篇关于 zookeeper 分布式组件学习的PPT。
在PPT制作过程中参考了尚硅谷的教学材料【尚硅谷】大数据技术之Zookeeper 3.5.7版本教程_哔哩哔哩_bilibili 和 Raft 以及 zookeeper 的论文原文。
PPT 采用zoho 来托管，您可以点击这里 获取到PPT原文
 您也可以通过鼠标右键下面的内容，另存为pdf版本的文件。</description>
    </item>
    
    <item>
      <title>Distributed System and MapReduce 02 | 分布式系统和MapReduce 02</title>
      <link>https://root-zr.github.io/en/2022/06/15/distributed-system-and-mapreduce-02-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8Cmapreduce-02/</link>
      <pubDate>Wed, 15 Jun 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/06/15/distributed-system-and-mapreduce-02-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8Cmapreduce-02/</guid>
      <description>这篇博客主要是关于 MIT 的公开课 6.824 分布式系统 的 lab 1相关内容，lab 1 要求我们实现一个分布式的mapreduce系统，并且已经为我们提供了一些基础的代码，lab 的地址请点击这里 。下面让我们从文件的架构开始一点点去了解我们所要做的事情。下面是一个精简了的代码结构图，它可以帮助我们理解 lab 1的内容。
单机mapreduce任务 首先我们需要明确的是main目录下的文件是我们的程序入口处， 如果我们执行mrsequential.go 文件将会启动一个单机的mapreduce任务，执行的命令如下
go run -race mrsequential.go wc.so pg*.txt 可以看到在执行的时候还传了两个参数，这两个参数的作用是什么呢？我们从代码中来观察一下，
if len(os.Args) &amp;lt; 3 { fmt.Fprintf(os.Stderr, &amp;quot;Usage: mrsequential xxx.so inputfiles...\n&amp;quot;) os.Exit(1) } mapf, reducef := loadPlugin(os.Args[1]) 可以看到 wc.so 是用来加载 map 和 reduce 函数的， 而 wc.so 文件则是由下面这个命令生成的，通过-buildmode=plugin可以以插件的形式将wc.go 文件里的函数封装起来，然后通过loadPlugin 函数重新加载出来。
 go build -race -buildmode=plugin ../mrapps/wc.go loadPlugin 函数是作者自己编写的，具体是封装了plugin.Open 和 p.Lookup两个函数的功能，最终的结果是获取到map 和 reduce 两个函数。
func loadPlugin(filename string) (func(string, string) []mr.</description>
    </item>
    
    <item>
      <title> From Maximum Convention Number to Cryptography| 从最大公约数到密码学</title>
      <link>https://root-zr.github.io/en/2022/05/12/from-maximum-convention-number-to-cryptography-%E4%BB%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%88%B0%E5%AF%86%E7%A0%81%E5%AD%A6/</link>
      <pubDate>Thu, 12 May 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/05/12/from-maximum-convention-number-to-cryptography-%E4%BB%8E%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%88%B0%E5%AF%86%E7%A0%81%E5%AD%A6/</guid>
      <description>这篇博客主要从我们小学时了解的最大公约数概念出发，一步步去了解数之间的关系，最后讲述它们是怎么被应用在密码学当中的。因为篇幅所限，再加上下文中提到的很多相关定理都需要用到离散数学的知识，所以本文中并不涉及到它们的证明，如果您对这些定理的证明感兴趣，请自行查阅相关的书籍。
最大公约数 我们的故事首先从最大公约数讲起，最大公约数是我们非常熟悉的内容了，如果有两个数a和b，存在一个数m，使得m能同时被a和b整除，并且不存在另外比m大且能同时被a和b整除的数，我们就称m是a和b的最大公约数，可以记为 $$ gcd(a,b) = m $$ 这个概念非常明确，如果真的给定了两个数，要去求它的最大公约数，我们也能很显然地相除一种暴力的解法。那就是让i从1到min(a,b)开始不断去判断是否满足同时被a和b整除，满足条件的最大值就是最大公约数。这种做法的时间复杂度也是很显然的，它是O(min(a/2,b/2))。这种做法在a，b都很大的时候显然不是一个值得提倡的做法，所以人们也想了很多办法去优化它，欧几里得算法就是一个很好的优化方案。
我们不妨假设a &amp;gt; b，则a一定可以表示为下面这种形式 $$ a = p \times b + r $$ 其中p表示a除以b的商，r表示余数。同样的b可以表示为 $$ b = q \times r + r_2 $$ 其中q表示b除以r的商，$r_2$表示余数。如此往复，最终我们将会得到余数$r_i$为0的情况，这时它上面的余数就是a和b的最大公约数。我们可以从一个简单的例子来看这个算法，加入a = 64，b = 42，整个过程可以表述为下面的情况。 $$ 64 = 1 \times 42 + 22
$$
$$ 42 = 1 \times 22 + 20
$$
$$ 22 = 1 \times 20 + 2 $$
$$ 20 = 10 \times 2 + 0 $$</description>
    </item>
    
    <item>
      <title>Distributed System and MapReduce 01 | 分布式系统和MapReduce 01</title>
      <link>https://root-zr.github.io/en/2022/04/20/distributed-system-and-mapreduce-01-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8Cmapreduce-01/</link>
      <pubDate>Wed, 20 Apr 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/04/20/distributed-system-and-mapreduce-01-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%92%8Cmapreduce-01/</guid>
      <description>这篇博客主要是学习MIT的公开课6.824分布式系统 的学习笔记，在课程一开始老师主要介绍了分布式系统的和MapReduce的基本概念，后续有关于实现一个具体的MapReduce的实验。
分布式系统的基本概念 首先当用户要访问信息的时候，一般需要一个WEB的网页接口去和后台的数据库操作。当用户量很大的时候一台机器就不足以支撑这么大的并发量了，同时数据库所在的服务器也有可能会出现问题。所以很自然的想法就是用多台机器来分担压力。如果足够理想，两台机器就可以把压力减小一般，一直这样下去……不过可惜的是现实中这是不可能的。
现在想法是有了，但是怎样去实现它呢？我们知道一台机器是不容易出现问题的，一台电脑是可以陪伴我们很多年的。但是在一个具有成千上万台机器的分布式集群中出现问题确实非常常见的事，所以人们只能尽可能保证容错，而容错机制主要包括下面三个特性：
 可用性（Availability）：我们要能用这个系统，但是它又时常会出问题，那我们只能定期去把数据备份起来了，所以备份可以保证这个系统是可用的； 可恢复性（Recoverability)：我们已经备份了数据，那就要保证在出问题的时候能恢复到出错前的状态。这里可用的一些操作就是更新日志，设置一些检查点，使用非易失性的存储介质（如硬盘），不能一不小心停电了然后什么都没了。 一致性（Consistency)：我们现在有了备份，那多个副本中的数据是不是能保证一致呢？比如在一个&amp;lt;key,value&amp;gt;的数据库中，张三要取1000元钱，然后发送请求导致主数据库更新了数据，但是就在发送更新副本的时候网断了，这就导致了数据的不一致。  而且就备份来说，它应该距离主体非常远，如果两台机器共用一个电源然后断电了或者该地发生了不可预见的地震，后果都是难以承受的。另外分布式系统作为一个基础设施，它有三个很重要的组成，就是存储系统，通信系统和计算系统。
MapReduce MapReduce是谷歌大数据三驾马车中的其中一篇论文，它被提出的目的是用来解决海量网页数据索引和排序之类的问题。它包含Map和Reduce两个过程，以WordCount为例，它的计算过程如下图所示：
当我们面临着一个大文件的时候，谷歌的文件系统GFS(Google File System)会把它差分成多个64kb的块，用来做任务分配的master服务器知道它们具体在哪台机器上，然后它会指定work machine去执行Map的操作。加入这些文件块的存放位置和work machine不是同一台机器，那就需要通过网络通信来进行数据交换，可是这样会导致效率下降，所以一般都会将它们放在同一台机器上，work machine只需要做一个文件读取的操作就可以了。Map(k,v)的v指的就是某一个块的全部文字，所以下面只需要将单词拆分开然后变成key,1的形式就可以了。
图片来源：Google MapReduce论文
在整个Map的过程中master是不需要去一致盯着每台机器去做运算的，每个work machine会将自己运算的中间结果保存在自己的本地磁盘上。以上图中的INPUT 1为例，它最终会保存（a,1)和(b,1)两个值。
然后是Reduce的过程，MapReduce worker通过网络收集所有完成了map worker中&amp;lt;key(i), 1&amp;gt;的任务task，从存储在各个Map worker磁盘上收集数据。这里并不要求每一个Map的所有任务都完成，如果只请求(a,1)这个Map过程，只要work machine完成了这一个任务，就可以将结果返回，不用等全部工作完成。Reduce的伪代码可以表示如下：
图片来源：Google MapReduce论文
它的实现相对简单一点，只是对这些收集到的信息做一个加总的操作，计算出长度就行了。</description>
    </item>
    
    <item>
      <title>Source Code Analysis of qsort Function in C Language| C语言qsort源码分析</title>
      <link>https://root-zr.github.io/en/2022/04/10/source-code-analysis-of-qsort-function-in-c-language-c%E8%AF%AD%E8%A8%80qsort%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sun, 10 Apr 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/04/10/source-code-analysis-of-qsort-function-in-c-language-c%E8%AF%AD%E8%A8%80qsort%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>在阅读这篇博客之前请确保您已经理解了快速排序的思想。
qsort函数位于GLIBC的stdlib目录下，内部实现了快速排序的功能，我们先不去管这个函数内部具体是怎么实现的，先来考虑如果我们要调用它，该怎么去调用呢。很显然，我们需要给它传入一个待排序的数组array，由于C语言会将数组参数转为指针，所以很自然地要传入一个数组长度的值，一般表示数组长度就是arraySize。看起来没什么问题，那我们来看一下它对外封装的接口是不是如我们所想呢。
看来我们的考虑还是欠佳，封装的接口有四个参数，除了传入的数组以外还要传入数组个数，每个元素的大小和一个比较函数。比较函数还是很容易理解的，因为我们毕竟不能保证始终要求它给我们升序排列，也不能保证随便什么内容都要求程序可以不出错的给我们排好序。但是为什么传入数组大小的时候必须要分开传参呢，我们自己写函数的时候也是只传了一个参数表示数组长度的呀。在分析原因之前我们先按照提供的接口简单测试一个例子吧。
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; int Cmp(const void * a, const void * b) { return ( *(int*)a - *(int*)b ); } int main() { int n; int values[] = { 2, 5, 4, 1, 3 }; printf(&amp;#34;排序之前的列表：\n&amp;#34;); for( n = 0 ; n &amp;lt; 5; n++ ) { printf(&amp;#34;%d &amp;#34;, values[n]); } qsort(values, 5, sizeof(int), Cmp); printf(&amp;#34;\n排序之后的列表：\n&amp;#34;); for( n = 0 ; n &amp;lt; 5; n++ ) { printf(&amp;#34;%d &amp;#34;, values[n]); } return(0); } 排序的结果如下图，</description>
    </item>
    
    <item>
      <title>Some Reviews About Movie The Great Learning | 纪录片电影《大学》观后感</title>
      <link>https://root-zr.github.io/en/2022/04/08/some-reviews-about-movie-the-great-learning-%E7%BA%AA%E5%BD%95%E7%89%87%E7%94%B5%E5%BD%B1%E5%A4%A7%E5%AD%A6%E8%A7%82%E5%90%8E%E6%84%9F/</link>
      <pubDate>Fri, 08 Apr 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/04/08/some-reviews-about-movie-the-great-learning-%E7%BA%AA%E5%BD%95%E7%89%87%E7%94%B5%E5%BD%B1%E5%A4%A7%E5%AD%A6%E8%A7%82%E5%90%8E%E6%84%9F/</guid>
      <description>《大学》是清华大学出版社有限公司出品的，由孙虹、王静、柯永权三位导演的纪录片类型的电影。它讲述了四位在清华读书或者工作的人在不同的人生阶段，在不同的人生境遇所做出的选择。看完之后还是有很多的感触。
首先介绍的是一位上海的考生，他最终成功去了清华读书。但是在这个过程中也是有一些起伏，从一开始看感觉这位同学基本是可以很有把握地走进清华，但是高考却给他带来了一点小小的刺激，让他的道路不显得那么一帆风顺。在看的过程中我最有感触的地方是他在等待高考成绩出，以及出成绩之后的那一瞬间的心态，因为我的能力和这位同学差了很远，所以主人公其他的事迹我也很难有共鸣。我是以过来人的心态看的这一片段，现在看起来觉得心态相对平和，可是代入进自己高考的那段时间我却有着比主人公更加激动的情绪。寒窗苦读十多年，更多时候学生自己，家长之间，老师之间都希望可以通过高考成绩来给这个人定性。这种心情我非常能理解，因为毕竟这是一场非常公平的测试。如果让学生或者家长之间不去竞争成绩，难免大家会去找一些新的领域去竞争和攀比，这样导致的效果可能会更差。可是当所有人都把注意力放在这里的时候，难免会产生过大的压力，也会使一些同学的心态出现问题。
直观的一个表现就是人们会去渴望给学校划分三六九等，借此来巩固自己在高考时为自己争取到的“地位”，如果仅仅是如此倒也没有什么，但怕就怕这些同学可能会躺在历史的功劳簿上，放弃在大学时继续努力，这只会白白浪费大学黄金的学习时间；给大学评级导致的另外一个问题可能是，如果真的有人对此信以为真，那就会出现愿意为了去到所谓“等级更高一点”的学校而放弃自己更加心爱的专业的额情况，这对考生个人的人生有时也会带来很大的影响。
后面还介绍了一位水利水电工程系的博士生毕业之后放弃可能的留校机会去基层服务人民的事迹。这里最触动我的地方在于他所说的一段话，大致意思是说当外界直到他的决定之后对他的评价可能不是鼓励，甚至不是保持中立，而是一些谩骂和嘲讽，他们认为主人公这么做主要是想凭借他的身份给自己带来一些利益。
最后主人公说，如果是骂一个不好的人，人家也不在乎你去骂他。但是对于一个本来有点理想的人，要是去诋毁他，嘲笑他，他本来可能做这些事就只是想得到大家的一点认可，却被不断diss，这可能会给当事人带来一定的创伤。我相信很多人也曾经想过用自己的所学去造福一方百姓这样美好的愿景。只不过随着岁月的流逝，他们渐渐觉得这个想法不够真实，甚至很难将它说出口。所以当这样的例子发生在现实中的时候，大家会带着很复杂的心情去评论，这样也就出现了一些不好的评论。
相信随着我们时代的发展，越来越多的人会投身于此，这件事终有一天是人们都想去做，也都想做好的事。后续查了一下发现主人公的基层服务之旅还是很有成效的，希望主人公能坚持下去，实现心中的理想。</description>
    </item>
    
    <item>
      <title>Spoken English TipsⅡ| 英语口语小技巧——弱读和吞音</title>
      <link>https://root-zr.github.io/en/2022/04/01/spoken-english-tips-%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%BC%B1%E8%AF%BB%E5%92%8C%E5%90%9E%E9%9F%B3/</link>
      <pubDate>Fri, 01 Apr 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/04/01/spoken-english-tips-%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%BC%B1%E8%AF%BB%E5%92%8C%E5%90%9E%E9%9F%B3/</guid>
      <description>介词通常的读法 介词通常会采用和字典中不太一致的读法，主要是为了方便说。
 to -&amp;gt; /tə/ for -&amp;gt; /fər/ or -&amp;gt; /ər/ and -&amp;gt; /ɛnd/ at -&amp;gt; /ət/ of -&amp;gt; /əv/  例句：
 He&amp;rsquo;s applying to Standford to get an MBA. This is for you. Do you want this or that? Danny went out and got drunk.  /h/可以吞音 he, his, her, him, have, had, has等如果不是在强调这个词，/h/可以吞掉。
 I think he&amp;rsquo;s(kiz) really smart. Did you(jʊ) tell her(lər) what he did? I have a bunch of work to do.</description>
    </item>
    
    <item>
      <title>Spoken English TipsⅠ| 英语口语小技巧——连读</title>
      <link>https://root-zr.github.io/en/2022/03/31/spoken-english-tips-%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E5%B0%8F%E6%8A%80%E5%B7%A7%E8%BF%9E%E8%AF%BB/</link>
      <pubDate>Thu, 31 Mar 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/03/31/spoken-english-tips-%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E5%B0%8F%E6%8A%80%E5%B7%A7%E8%BF%9E%E8%AF%BB/</guid>
      <description>辅辅连读 如果前一词的词尾和后一词的开头发音正好相同，则直接合并。
 bit tired full lunch more room start time this city  相同发音部位的音连读
 喉咙（They are gone) 牙齿后面（Had some) 嘴唇牙齿（Tough pill)  辅元连读 词尾的辅音连接到下一个词的开头音
 My name is Adam. Picking up on the American intonation is super important.  元元连读  第一个词是元音结尾的 第二个词是元音开头的 看第一个词的词尾音决定连读  如果以/I/或者/i/结尾，后面接/j/
 She ate my apples. He isn&amp;rsquo;t a good guy.  以/u/或者/ʊ/结尾，后面接/w/
 Go away. I need to do a lot today.  常用的同化 d + y -&amp;gt; /ʤ/</description>
    </item>
    
    <item>
      <title>A Method Convert Latex to Word| 一个将latex公式转换为word公式的小窍门</title>
      <link>https://root-zr.github.io/en/2022/03/23/a-method-convert-latex-to-word-%E4%B8%80%E4%B8%AA%E5%B0%86latex%E5%85%AC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BAword%E5%85%AC%E5%BC%8F%E7%9A%84%E5%B0%8F%E7%AA%8D%E9%97%A8/</link>
      <pubDate>Wed, 23 Mar 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/03/23/a-method-convert-latex-to-word-%E4%B8%80%E4%B8%AA%E5%B0%86latex%E5%85%AC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BAword%E5%85%AC%E5%BC%8F%E7%9A%84%E5%B0%8F%E7%AA%8D%E9%97%A8/</guid>
      <description>今天在看IEEE网页上的论文的时候发现它的公式竟然可以被复制成多种格式.
欣喜至于便去了解了一下这种技巧。然后发现其实是因为它的网页中引入了MathJax.js脚本。
&amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;/xploreAssets/MathJax-274/MathJax.js?config=default&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 同样的道理，我们也可以按照这种方式来编写latex公式，然后通过浏览器解析之后再将它复制成word对应的代码文本。道理很简单，那么具体该怎么做呢？
首先我们就需要一个.html的文件了，因为是要浏览器来解析的。然后将脚本导入进来。可以看到整个页面中基本只引入了MathJax的脚本，不需要别的什么设置。然后把我们需要的公式用latex的方式写在里。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;#34;&amp;gt; &amp;lt;/script&amp;gt; &amp;lt;title&amp;gt;tex to word&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; \begin{equation*} q_{j}=W\cdot\vec{x}_{j:j+R-1}+\vec{b} \tag{1} \end{equation*} &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 然后通过浏览器打开，鼠标右键将其保存为MathML code，如下图所示：
然后在word中选择插入公式，将拷贝出来的文本以纯文本的形式粘贴到公式块中就完成了。如果要转换不同的公式只需要在上面的标签中不断添加公式就可以了。
不过还是可以看到一个小缺陷，我们在tex格式里是加了\tag{1}的，而且网页也能显示，但是粘贴到word里就没有了。所以只能用word的方式来插入，选择插入——&amp;gt;文档部件，选择域，如下图：
然后在公式编辑区域里输入#(数字)，按下回车就可以成功编号了。
参考资料：
https://tex.stackexchange.com/questions/25223/embed-latex-math-equations-into-microsoft-word</description>
    </item>
    
    <item>
      <title>My Internship Experience | 我的5个月实习心得</title>
      <link>https://root-zr.github.io/en/2022/03/19/my-internship-experience-%E6%88%91%E7%9A%845%E4%B8%AA%E6%9C%88%E5%AE%9E%E4%B9%A0%E5%BF%83%E5%BE%97/</link>
      <pubDate>Sat, 19 Mar 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/03/19/my-internship-experience-%E6%88%91%E7%9A%845%E4%B8%AA%E6%9C%88%E5%AE%9E%E4%B9%A0%E5%BF%83%E5%BE%97/</guid>
      <description>2021年8月，我正式开始了我人生的第一次实习旅程。因为校企合作的关系，所以我和实习的公司应该属于被动的关系。不过也是由于这层关系，让我有了一个难忘的实习经历。
我是在大数据部门实习，主要参与的业务包括两个方面。一个是和数据直接相关，通过和数据的直接交互，保证数据的完整，有效。还有就是一些和公司业务相关的一些操作；另一部分是进行软件开发，因为前一部分已经有了可靠的数据，所以要基于这些数据进行软件开发和产品设计。
首先我的两个leader都是特别年轻，而且具有人格魅力的人。leader 1是我所在部门的大老板（后文简称老板），我主要是在做开发的时候在他的组。leader 2 是招我进部门的人（后文简称leader)，还记得当时面试的时候主要都是我在说话，导致我一度认为他不善言辞，后面我才知道我错了，还错的很离谱，而他也正好是我第一个组的leader，这也算是缘分吧。
我最开始就是做数据分析，这部分的时间并不长，只有一个多月，再加上刚进入公司需要申请各种权限，熟悉公司的环境和氛围，所以感觉并没有太多的心得。值得一提的是，我刚进入公司的时候由于新的环境，再加上工作语言不熟悉，导致我非常紧张，不太敢于和同事说话，幸运的是我进入公司的第一位引路人A同事特别好，让我能够慢慢放松，慢慢地融入大家。而且进入公司会有很多的环境要配置，有各种权限要申请，我个人真的是一团乱麻，他也帮了我很多，在同期实习的别的同学还困扰在各种问题中时我已经可以了解业务了。我想以后我在真正开始第一份工作的时候就不会像之前那么紧张了，这也算是一种进步吧。
由于公司实行敏捷开发，所以每天都有站立会议，这时就体现出leader特别强的语言组织能力和讲故事的能力，不管是什么样的任务，他都能将其叙述地特别具有逻辑性。比如，我现在要完成A这样的一个事情，之所以要做A，是因为有怎样怎样的好处，它和我们整个业务的关系是什么，处于什么样的位置。基于这样的一个背景，那我现在就需要做B,C,D等等一系列的工作，现在我们到了哪一步，需要有什么问题需要被解决……会以一种讲故事的方式展开，这是觉得特别具有魅力的一点。另外我觉得他是将公司的企业文化和价值观具象化的人，如果说公司培训那么多企业价值观的内容都是平面的，那他就是立体的。当他在你面前和你交谈的时候，他说的话中体现的逻辑性特别具有魅力。用老板的话说，leader是一个极具演讲天赋的人。
一开始都是要从学习和了解业务为主，可是当我发现我要了解的技术包括Hadoop, spark, Scala等等一系列的大数据组件，还有公司用来自动化流程的一些工具Jira, Jenkins等等，这么多新的内容放在面前，我确实像面对着一个刺猬，无处下爪。怀着带着任务学习的心态，我先从语言着手，然后再去理解语言下的工具，当会使用的时候就能开始做一点小事，当做事遇到问题的时候再去查阅资料就能理解比较底层的原理，当了解之后也觉得这些东西可能没有那么困难。在学校学习的时候，一般都是要从最核心的地方开始，一步步向上封装，这也是一种比较新的感悟。所以我觉得当面对一个新鲜的事物的时候，不要被这件事本身的庞大给吓跨，从离自己最近的那件小事开始学习，一点点去靠近，当翻越过的时候回头再看，可能会发现当时自己以为的山丘其实就是一个小土堆。
很快，一年一度的秋季校园招聘开始了，因为我的家庭条件不算好，自己有生存的压力，所以希望自己可能有一个薪酬相对高一点的工作，为此适当放弃自己的一点健康我感觉也能接受。这点和我实习的公司不是特别一致，所以我也加入了秋招的行列。这时有更多的问题暴露出来了，一个是因为我加入实习的时间是8月，这个时间是公司定的，我个人没法改变，所以到秋招其实也没有太长的时间；同样也因为时间短，所以可能并没有多少实际的，能够拿出手的项目可以和面试官说。我个人感觉数据分析是一个不太能够量化工作量的一个工作，有时候程序运行一遍要几个小时，有时候几个小时过去了可能还得不到想要的一个效果。而且当我思考了一点可以优化的内容，反应在代码上也就是几行，而且这个深思熟虑的结果表述出来的话在别人看来很可能就是显然的一个事情。
为此，我开始去做开发的工作，这样的话自己写了一行代码就有一行代码的效果。一开始确实是这样，感觉自己想做的和正在做的事情一致了，所以开始变得比较有干劲。我的第二位引路人B同事也很nice，他每次给我小的ticket的时候都是会给我官方的文档，然后再告知要达成的目标。这也养成了我阅读官方文档的习惯，我发现相比较于在英语阅读上花费的时间和在中文的真假信息之间做选择，前者甚至花费的时间更小。但是新的问题又随之出现了，因为我感觉自己的时间开始不够用了，虽然给我的任务并不重，但我一方面学的东西不多，再者各种技术也不够熟练，所以上班时间基本都要全力去工作。找工作的事情只能放在晚上，可是算法题有时候一道题就得做一个小时，还有一些面经要背，晚上并没有那么多的空闲时间给我。这时我的做法只能是坚持去做这件事，相信坚持下去能得到好的结果。幸运又再次降临，很快我就顺利地得到了让我满意的offer。或许这也是我的另一个经验，当你身处于多件事情交错的一个环境之下，此时只能在其中勉强维持，但是看不到出路的时候，不妨坚持一下，再坚持一下，幸福就在拐角处。
工作的问题目前已经不是困扰我的主要因素了，而我的实习经历也才开始了两个月左右，这时我想把自己重心完全放在工作上，想做出一点成绩。我的第三位引路人C同事也出现了，他把他的一些边缘任务分给我，然后慢慢深入，让我对整个项目要做的事情有一个了解。我的任务开始慢慢重了起来，而与此同时，我所犯的错误也开始多了起来。当时我要发布一个新的版本要到生产环境，可是因为换了新的部门，而我的信息还停留在之前的部门，所以发布就出现了延迟。老板催问进度，这时我应该及时告诉老板的，但是内向的性格有开始兴风作浪，想着这儿是管上百人的领导啊，他这么忙，我去打扰他好像不太合适。况且这个任务虽然是我在做，但毕竟我遇到问题，C同事会帮我，所以就沉默了。现在回想，这是做的特别不好的事情，既然我想锻炼自己，就应该把自己等同于一个正式的员工，即便我做的工作可能并不算核心，我也应该及时让老板知道。而且这也是老板一开始就希望我们做到的东西，他更愿意我们去了解真实的项目，即使我们在这个项目里做的东西是边缘的。换句话说，他希望我们知道自己做的一个任务即使再小，也能知道它在整个项目中发挥的作用，这种大局观的意识是我的又一个收获，我希望我能在后面的工作中能坚持去做这件事。
不管是我的老板还是leader，他们都是希望我能有一个大局观的视野，对业务有一个清晰的了解。可是我是更希望能够去了解一些技术的细节，所以这之间应该是存在者一点分歧。不过在我以后会做的项目中，我应该会愿意去花一些时间去培养对整个项目的大局观。
转眼就来到了12月，后续虽然也实习了一个多月，但是因为赶上国外的同事过圣诞，国内的同事也要休剩下的年假，所以基本没有过多的任务量，比较平淡地度过了最后这段时期。复盘我的整段实习经历，我对自己的表现其实不算是特别满意，主要是因为我感觉自己和领导，同事之间缺乏交流，对项目的了解也不算特别清晰，最主要的是我一直考虑的是这段实习能带给我什么，却没有考虑到我的到来可能会为部门带去什么，哪怕是为部门带去一种比较年轻的思想也行。
总而言之，这是我第一段工作的经历，它带给我很多的回忆，包括友善的同事，幽默又睿智的领导，公司开放的氛围等等，所以应当是我一段很美好的经历！</description>
    </item>
    
    <item>
      <title>Knapsack Problem | 背包问题</title>
      <link>https://root-zr.github.io/en/2022/02/24/knapsack-problem-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 24 Feb 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/02/24/knapsack-problem-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <description>01背包问题 有N 件物品和一个容量为bag 的背包。第i 件物品的重量是w[i]，价值是v[i]。 求解将哪些物品装入背包可使价值总和最大。
暴力算法 我们首先想到的应该是穷举所有的可能，然后把最好的那一个给返回。而在穷举的过程种我们需要考虑的问题仅仅是对于第i个物品，到底要不要把它放入背包。所以可以用递归的方式很自然地解决。
/** * * @param w 物品的重量 * @param v 物品的价值 * @param i 第i个物品 * @param alreadyW 已经放入背包的重量 * @param bag 背包所能承受的最大重量 * @return 最大价值 */ public static int recur(int[] w,int[] v,int i,int alreadyW,int bag){ if(alreadyW &amp;gt; bag || i &amp;gt;= w.length) return 0; //背包超重或者没有物品可以装  int totalVal1 = 0,totalVal2 = 0; totalVal1 = recur(w,v,i+1,alreadyW,bag); //第i个物品不放入背包  if(alreadyW+ w[i] &amp;lt;= bag) totalVal2 = recur(w,v,i+1,alreadyW+ w[i],bag) + v[i]; //第i个物品放入背包  return Math.</description>
    </item>
    
    <item>
      <title>Why Do I Start to Write Blog| 为什么要开始写博客</title>
      <link>https://root-zr.github.io/en/2022/02/13/why-do-i-start-to-write-blog-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 13 Feb 2022 13:39:37 +0800</pubDate>
      
      <guid>https://root-zr.github.io/en/2022/02/13/why-do-i-start-to-write-blog-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/</guid>
      <description>我开始写博客应该是2020年的时候。那时正处于新冠疫情期间，由于只能在家里上课，学习的效率难免受到影响，再加上那时的课业压力有点大，所以我便开始尝试来写技术博客来记录自己遇到的一些问题和学习的心得。
最开始的时候都是把文章保存在本地磁盘，因为害怕自己写的东西可能会存在一些错误，从而误导读者，所以不敢发布到网络平台上。后面我开始逐渐说服了自己，因为即便是文章有错误被读者指正了，我也能够改正这个也许一直都不曾发现的问题。从另外一个角度来说，如果自己的一些经验可以帮到千里之外的某一个人的话那更是一件让人非常高兴的事。
于是我开始渐渐将自己写的博客发到自己的知乎上，看着每一篇文章都能被几百个人阅读感觉还是非常不错的。不过慢慢我也发现了知乎存在的一些问题。
首先它是一款带有社交性质的产品，所以我在平台的一言一行可能都想服从于我给自己设定的一些“人设”，有些真正的心里话反而不敢，也不愿意发出来；除此之外我发现虽然目前知乎的用户群体学历是最高的，但从宏观的角度看其实也跟“刚下飞机，年薪百万”差了很远，人们对于技术类的博客可能也并不是特别的关注；最后我发现人们问的问题往往都带着一个预期的答案，比如如果有人的问题是“我大三了绩点比较低还有机会保研吗”，可能他会希望看到类似于&amp;quot;no problem!&amp;ldquo;这种答案，真正去对这个问题分类讨论往往不会受到更多关注。
于是乎，我觉得自己可以搭建一个个人博客，这样的话我就能够完全将自己的所思所想发出来，这样就不用有太多顾率。说干就干，在网上大致了解了一下hugo的用法，然后花了大半天的时间完成了这个个人博客的搭建，虽然大部分的时间都花在了浏览不同的网站主题上面。
最后，非常感激和荣幸您能阅读我的博客！</description>
    </item>
    
  </channel>
</rss>
